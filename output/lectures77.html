<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type"/>
<meta content="pandoc" name="generator"/>
<title></title>
<style type="text/css">
/*<![CDATA[*/
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode, table.sourceCode pre 
   { margin: 0; padding: 0; border: 0; vertical-align: baseline; border: none; }
td.lineNumbers { border-right: 1px solid #AAAAAA; text-align: right; color: #AAAAAA; padding-right: 5px; padding-left: 5px; }
td.sourceCode { padding-left: 5px; }
code.sourceCode span.kw { color: #007020; font-weight: bold; } 
code.sourceCode span.dt { color: #902000; }
code.sourceCode span.dv { color: #40a070; }
code.sourceCode span.bn { color: #40a070; }
code.sourceCode span.fl { color: #40a070; }
code.sourceCode span.ch { color: #4070a0; }
code.sourceCode span.st { color: #4070a0; }
code.sourceCode span.co { color: #60a0b0; font-style: italic; }
code.sourceCode span.ot { color: #007020; }
code.sourceCode span.al { color: red; font-weight: bold; }
code.sourceCode span.fu { color: #06287e; }
code.sourceCode span.re { }
code.sourceCode span.er { color: red; font-weight: bold; }
/*]]>*/
  </style>
</head>
<body>
<!-- <script type="text/javascript" -->
<!--   src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> -->
<!-- </script> -->
<script src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript">
</script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>
<link href="http://www.cs.dartmouth.edu/~scot/cs10/azul.css" rel="stylesheet" type="text/css"/>
<div id="menubar">
<ul>
<li><a href="http://www.cs.dartmouth.edu/~scot/cs10/syllabus.html">Syllabus</a>
<li><a href="http://www.cs.dartmouth.edu/~scot/cs10/schedule.html">Schedule</a>
<li><a href="http://www.cs.dartmouth.edu/~scot/cs10/sa/short_assignments.html">Short assignments</a>
<li><a href="http://www.cs.dartmouth.edu/~scot/cs10/lab/lab_assignments.html">Labs</a>
<li><a href="http://www.cs.dartmouth.edu/~scot/cs10/exams.html">Exams</a>
<li><a href="http://www.cs.dartmouth.edu/~scot/cs10/software.html">Course software</a>
<li><a href="http://www.cs.dartmouth.edu/~scot/cs10/help.html">Get help</a>
</li></li></li></li></li></li></li></ul>
</div>
<div id="termtitle"> CS 10: Fall 2014 </div>
<h1 id="lecture-7-september-26">Lecture 7, September 26</h1>
<h2 id="code-discussed-in-lecture">Code discussed in lecture</h2>
<ul>
<li><a href="SimpleApplet.java">SimpleApplet.java</a></li>
<li><a href="DrawAMac.java">DrawAMac.java</a></li>
<li><a href="PsychBoxes.java">PsychBoxes.java</a></li>
<li><a href="ClickAMac.java">ClickAMac.java</a></li>
</ul>
<h2 id="short-assignment-4">Short Assignment 4</h2>
<p><a href="../../sa/sa4/sa4.html">Short Assignment 4</a> is due Monday.</p>
<h2>From last lecture</h2>
Finish SLL from last lecture.

<h2 id="graphical-applets">Graphical applets</h2>
<p>So far we have considered only applications. Another choice is to write an applet that appears as part of a web page. Rather than worrying about who has which browsers and all the incompatibilities that this causes, we will use a program called AppletViewer instead. But applets are different from programs. They have no <code>main</code>, for example, because they are intended to run under a web browser.</p>
<p>This style of programming is new to you. So far, when you have written Java programs, you have written the <code>main</code> method and some of the methods it calls. And maybe some of the methods <em>they</em> call. And so on, but eventually you get down to methods that are supplied with the Java system, such as <code>System.out.println</code>, methods of the <code>DecimalFormat</code> class (e.g., the <code>DecimalFormat</code> constructor and <code>format</code>), or methods of the <code>String</code> class (e.g., <code>length</code>). So you write the higher-level methods and the Java system supplies lower-level ones. The Java-supplied methods do not call methods we write. It seems obvious that the Java-supplied methods couldn't call the methods we write, because how would someone we've never met who wrote the Java-supplied methods know what methods we write?</p>
<p>When you write an applet, you don't create a <code>main</code> method. More precisely, there is a <code>main</code> method, but you don't have to write it. It's provided by the AppletViewer (or whatever is running your applet). Yet, the AppletViewer does expect certain methods to be in your program, and it will call them. It uses default versions of these methods in case you don't provide them, but these default methods usually don't do anything.</p>
<p>Here's one way to think of this setup. You have created plenty of programs that called methods you didn't write, such as <code>System.out.println</code>. These methods were supplied by someone/something else, and you expected them to be there. Well, with applets, the situation is reversed: whoever wrote the AppletViewer will call methods that he or she didn't write, but that you will provide.</p>
<p>Just to complete the circle, the methods that you include in your applet may include calls to other methods that you did not write but were supplied with the applet software. So here's the picture for an applet, with methods on a shaded background being supplied with Java:</p>
<div class="figure">
<img src="applet-tree.png"/><p class="caption"></p>
</div>
<h2 id="design-pattern-the-template-pattern">Design pattern: the template pattern</h2>
<p>Architects discovered that certain problems arise again and again in the design of buildings, and that they could use certain solution approaches to solve them. For a trivial example, consider the following problem: a room needs light. One possible solution approach would be to install light fixtures. Another possible solution approach would be to add windows or skylights. Each of these possible solutions is a design pattern. Note that a design pattern is not a design. It does not tell you how many light fixtures or windows are needed and where to put them. It is an approach that often leads to a successful design.</p>
<p>In 1977 Christopher Alexander collected a number of these patterns and wrote about them. Ten years later Kent Beck and Ward Cunningham wrote a paper describing their experiments in applying design patterns to computer science design problems. In 1995 Gamma, Helm, Johnson, and Vlissides (known as the "Gang of Four") published a book titled <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>. It gives dozens of design patterns. Our textbook discusses software design patterns on page 63, listing over a dozen patterns that appear later in the book.</p>
<p>One of these design patterns is the <strong>template pattern</strong>. A program is written to solve a problem, such as performing the necessary display and other operations needed for an applet. Low-level details (e.g., what is to be displayed) are not supplied, however. The high-level code is the template, and the low-level details are supplied by method calls to functions that have not been written or are simple default methods that usually do nothing. In our case we will extend the class <code>JApplet</code>, which supplies the template. We will then override certain methods including <code>init</code> (which allows you to initialize variables, sort of like a constructor).</p>
<h2 id="awt-and-swing">AWT and Swing</h2>
<p>AWT and Swing are toolkits for producing Graphical User Interfaces (GUIs). The AWT (Abstract Windowing Toolkit) was included in the original Java language. It was designed to be multiplatform, so that Windows, Mac, UNIX, and other operating systems would all be able to use it without modification. The idea was "write once, run anywhere." AWT was designed to use the buttons, windows, etc. that were supplied by the platform, however. GUIs that looked good on one platform would appear a bit different on other platforms, causing problems. The result was, "write once, debug everywhere."</p>
<p>Swing is a newer windowing toolkit originally introduced as a standard extension to Java 1.1 (thus the name javax.swing, with the "x" for extension). It became a standard part of Java 2, and it continues on in the current release of Java. Instead of using native buttons, etc., it paints its own, making things a bit slower but more uniform across platforms.</p>
<p>We can use both AWT and Swing, giving us at least two ways to do pretty much everything. The Swing versions of classes start with a "J" (so that <code>JButton</code> is from Swing, whereas <code>Button</code> is from AWT). Swing is considered to be more powerful and flexible, so we will usually use it. However, some drawing commands and other methods only appear in AWT. We will use AWT for these methods and Swing for providing most of the GUI.</p>
<p>Unfortunately, even Swing is not quite "write once, run everywhere." Those of you using Mac OS X will quickly come to recognize the problem, because the Aqua interface overrides some of the properties that you try to assign to your GUI via Swing.</p>
<p>We will barely scratch the surface of AWT and Swing. They are huge, with hundreds of classes and more methods than anyone understands. Fortunately we can learn a few useful ones and several general principles which will let you learn new information as needed.</p>
<h3 id="packages">Packages</h3>
<p>Java has a huge library. It is useful to group classes into groups that do the same sort of thing. These groups are called <strong>packages</strong>. Examples are AWT (full package name: java.awt), which contains all of the AWT classes, and Swing (full package name: javax.swing) which contains the Swing classes. The names and dots actually correspond to a file structure. There is a directory (folder) named <code>java</code>, and within it is a subdirectory named <code>awt</code>. All of the code for the AWT classes lies in that subdirectory.</p>
<p>To put a class in a package, say <code>goodStuff</code>, you simply add</p>
<pre class="sourceCode"><code class="sourceCode java"><span class="kw">package</span><span class="kw"> goodStuff;</span></code></pre>
<p>as the first statement of the file defining the class. If you don't do that, your class is automatically added to the default package. We will do things with packages later in the term.</p>
<h2 id="gui-components">GUI components</h2>
<p>A component is anything that occupies visual space on the window: buttons, menus, text fields, scroll bars, and so on. We will also see how to create a "canvas" component that we can draw on.</p>
<p>Components are added to <strong>containers</strong>. We add a GUI component to a container by calling the <code>add</code> method. A <code>JApplet</code> has a <strong>content pane</strong>, which is the primary container for the applet. The <code>JApplet</code> class has a method <code>getContentPane</code>, which returns a reference to <code>Container</code>. We'll see it in use in a moment.</p>
<p>For now we will have only one component to add to the content pane: a drawing canvas. Eventually we will learn how to add several components and lay them out aesthetically on the applet window.</p>
<h2 id="simpleapplet">SimpleApplet</h2>
<p>Applets are designed to run on web pages. In that case you need to supply an HTML file. When developing code, however, it is simpler to use an AppletViewer program, and so that's what we'll do. When we run an applet under Eclipse we can dispense with the need for an HTML file. We need only a Java file.</p>
<p><a href="SimpleApplet.java">SimpleApplet.java</a> shows such a Java file. It must have the two <code>import</code> statements. These statements allow us to refer to classes without giving their full names. The full name would include the package name and class name. (See Section 1.8 in the text for more details.) If we left out the import statement, the class header for <code>SimpleApplet</code> would have to be</p>
<pre class="sourceCode"><code class="sourceCode java"><span class="kw">public</span> <span class="kw">class</span> SimpleApplet <span class="kw">extends</span> javax.<span class="fu">swing</span>.<span class="fu">JApplet</span> {</code></pre>
<p>The first import statement imports all the classes in the package <code>awt</code>. (The "*" says to import all classes.) The second imports all classes in the package <code>swing</code>, which includes the class <code>JApplet</code>. We then define a class <code>SimpleApplet</code> as a subclass of <code>JApplet</code>.</p>
<p>The first line of the applet declares and initializes the variable <code>serialVersionUID</code>. We declare and initialize this variable to avoid a warning message. If you leave it out, Eclipse will give a yellow triangle warning. If you click on it, it will offer to supply the default declaration that you see in the code. For this course, this will be all that you need to know about that variable.</p>
<p>The method that we override in the <code>JApplet</code> is <code>init</code>. This method is automatically called when the applet begins. (It's one of the methods that is called by code that you don't write.) The <code>init</code> method is where we intialize all of the things that the applet needs, just as a constructor does for classes. We can also set the size by calling the <code>setSize</code> method, giving it the width and height of the applet window, in pixels. The default window size is <span class="math">100 × 100</span> pixels. We then get the content pane of the <code>JApplet</code> and add a <code>Canvas</code> object to it. This is the drawing canvas. Finally, we call <code>setVisible(true)</code> in order to make the applet show up on the screen.</p>
<p><code>Canvas</code> is an <strong>inner class</strong>. It extends <code>JPanel</code>. We will use <code>JPanel</code> objects for two purposes in this course. The first is as a container. For example, we can add several buttons to a <code>JPanel</code> and then add the <code>JPanel</code> to the the content pane of a <code>JApplet</code>; we'll do that later in the course. The other is as a canvas to be drawn on, and that is how we use it here.</p>
<p>We'll use inner classes more later in the course. Objects in an inner class (here, <code>Canvas</code>) can access the instance variables and methods of the enclosing class (here, <code>SimpleApplet</code>). Note that you do <em>not</em> put an inner class in its own .java file; it goes inside its enclosing class in the file for the enclosing class.</p>
<p>In the <code>Canvas</code> class, we override the <code>paintComponent</code> method, which is inherited from <code>JPanel</code>. The parameter <code>page</code> to <code>paintComponent</code> is a reference to a <code>Graphics</code> object. The <code>Graphics</code> class comes as part of the AWT. A <code>Graphics</code> object represents the window in which we draw; its instance variables are hidden from us, but it has a plethora of methods by which we can interact with the window. (See the <code>Graphics</code> class on the <a href="http://docs.oracle.com/javase/7/docs/api/">Java documentation</a> site to see all of them.) This window has its origin at the upper left corner, and it has integer coordinates to identify pixels. The <span class="math"><em>x</em></span>-axis increases from left to right (as you're probably used to), but the <span class="math"><em>y</em></span>-axis goes <em>down</em> as the <span class="math"><em>y</em></span> values increase. (You're probably used to the <span class="math"><em>y</em></span>-axis going up as <span class="math"><em>y</em></span> increases from your math courses. In computer graphics, it is customary to have the <span class="math"><em>y</em></span>-axis go down, so that the origin is the upper left corner.)</p>
<p>When you call one of these methods on a <code>Graphics</code> object, such the one that <code>page</code> references, the graphic is drawn onto the page. The line</p>
<pre class="sourceCode"><code class="sourceCode java">page.<span class="fu">drawString</span>(<span class="st">"An applet a day keeps the doctor away."</span>, <span class="dv">30</span>, <span class="dv">30</span>);</code></pre>
<p>says to tell the <code>Graphics</code> object that <code>page</code> references to draw the given <code>String</code> starting at (30, 30) and extending to the right. The point (30, 30) is the left end of the string's baseline. Characters are drawn with their bottoms touching the baseline, except for characters such as "y" and "g" that have descenders that go below the baseline.</p>
<p>Whenever you override <code>paintComponent</code>, <strong>the first line of the call should always be a call to <code>super.paintComponent</code></strong>. This lets the component that contains this component do its drawing. In particular this containing component fills in the background, which erases what was there before. Then you can draw over it.</p>
<p>When an applet becomes visible it draws itself. If an applet window is resized or (partly) covered and then uncovered the applet will redraw itself. The way it does this is by calling the method <code>paint</code>. <code>paint</code> calls several other methods, including <code>paintComponent</code>, a method to draw borders, and a method to paint subcomponents of this component. (So calling <code>paint</code> on the <code>JApplet</code> will automatically call <code>paint</code> on each component in its content pane.) <em>You should never override <code>paint</code></em>. Were you to do so, the other calls would not be made.</p>
<p>Sometimes we draw something new and want it to appear on the screen. <strong>The way to get the applet to redraw itself is to call <code>repaint</code>.</strong> This method eventually calls <code>paint</code>, but it does other things as well. <em>You should never call <code>paint</code> directly.</em></p>
<h3 id="running-an-applet">Running an applet</h3>
<p>To run an applet, we create a Java file and add it to a project, just as with an application. When we select "Run as" in the "Run" menu, however, we then select "Java Applet" in the cascading menu that appears.</p>
<h2 id="drawamac">DrawAMac</h2>
<p>To create our own applets, it is easiest to start with SimpleApplet.java and then modify it. Here, we'll create an applet named <code>DrawAMac</code>, which draws a Mac (the original, mid-1980s style of Mac):</p>
<div class="figure">
<img src="the-original-macintosh--january-24-1984-2500.jpg"/><p class="caption"></p>
</div>
<p><a href="DrawAMac.java">DrawAMac.java</a> implements the <code>DrawAMac</code> class. It has the same basic structure as SimpleApplet.java. After the <code>import</code> statements, it declares the <code>DrawAMac</code> class, saying that is a subclass of <code>JApplet</code>. It has an inner class (called <code>DrawAMacCanvas</code> this time, although <code>Canvas</code> would have worked just as well). This class implements a <code>paintComponent</code> method. As before, the parameter <code>page</code> holds a reference to a <code>Graphics</code> object when <code>paintComponent</code> is called by the applet.</p>
<p>The method <code>setColor</code> sets the drawing color to the color passed as a parameter. Everything drawn will be in that color until the drawing color is changed by a subsequent call to <code>setColor</code>. The default drawing color is black. Why the <code>Color.</code> in front of the word <code>blue</code>? There is a class named <code>Color</code> in the AWT, and it defines a public constant named <code>blue</code>, which represents the color blue.</p>
<p>We're not using it in the <code>DrawAMac</code> class, but there is a <code>drawRect</code> method, which is passed four integer parameters: the <span class="math">(<em>x</em>, <em>y</em>)</span> value of the upper left corner, the width of the rectangle, and the height of the rectangle. The <code>drawRoundRect</code> method, which we do use in <code>DrawAMac</code>, is passed those four parameters and two additional ones: the width and height of the arc that rounds out the corners.</p>
<p>The same methods with the word "fill" replacing "draw" result in the interior of the object being filled in instead of the outline drawn. Again, the object is filled with the current color, given by the most recent <code>setColor</code> call. The <code>fillOval</code> method is passed the same four integer parameters as <code>drawRect</code>, and it draws the filled oval whose bounding rectangle is given by the parameter values.</p>
<p>The other method used is <code>drawLine</code>. This method takes four parameters: the <span class="math">(<em>x</em>, <em>y</em>)</span> coordinates of one endpoint and the <span class="math">(<em>x</em>, <em>y</em>)</span> coordinates of the other endpoint.</p>
<h2 id="psychboxes">PsychBoxes</h2>
<p><a href="PsychBoxes.java">PsychBoxes.java</a> demonstrates how to use a switch-statement and a timer to animate the applet. The applet draws 55 nested boxes, rotating through four different colors. Then the boxes are redrawn, with the colors shifted over one position. This action is repeated forever, leading to a psychedelic effect in which the boxes seem to move.</p>
<p>Note that to stop this program you have to quit it (from a menu or by keystrokes or by clicking the "close" button on the window), because it runs forever.</p>
<p>The switch-statement has an expression that evaluates to an integer value from 0 to 3. The switch is followed by a sequence of cases enclosed in curly brackets. Each case has a value, and execution jumps to the case that matches the value of the expression. If no case matches, and a default case has been defined, then the default case is executed, and control passes to the statement after the switch otherwise.</p>
<p>Unfortunately, execution does not stop at the end of a given case unless a break-statement is put there. A break-statement causes control to go to the statement after the switch. Forgetting a break-statement is a common pitfall. The "fall-through" to the next case can occasionally be useful, but is more often a pain in the neck. Java inherited this bizarre syntax from C++, which in turn inherited it from C.</p>
<p>Here, we use the switch statement just to select a color. Then we call <code>drawRect</code> to draw a single rectangle in the given color. By cycling through the colors to choose the color in which each rectangle is drawn each time we draw all the rectangles, we get the illusion of the rectangles converging toward the center of the window.</p>
<p>This example uses the <code>Timer</code> class. Think of a <code>Timer</code> as an alarm clock that goes off at periodic intervals and causes something to happen. Here, it goes off every 100 milliseconds, or every 1/10th of a second. Each time that the <code>Timer</code> goes off, it calls the method <code>actionPerformed</code>. This method increments the variable <code>iter</code>, which takes us to the next set of colors in the cycle, and then calls <code>repaint</code>. The call to <code>repaint</code> then calls <code>paint</code>, which calls <code>paintComponent</code> on the <code>PsychBoxesCanvas</code> object. It is the <code>paintComponent</code> method that ends up drawing the 55 boxes every 100 milliseconds. Notice that <code>paintComponent</code>, in the inner class <code>PsychBoxesCanvas</code>, is allowed to access the private instance variable <code>iter</code> from the enclosing class <code>PsychBoxes</code>.</p>
<p>How does the <code>Timer</code> know to call the <code>actionPerformed</code> method of the <code>PsychBoxes</code> class? The answer is that <code>this</code> was passed as the second parameter of the <code>Timer</code> constructor. That parameter must be of type <code>ActionListener</code>. <code>ActionListener</code> is an interface with a single method: <code>actionPerformed</code>. Thus the timer class knows that whatever object is passed to it has an implementation of this method. It simply calls it every time that the timer goes off.</p>
<p>Here we have another example of another design pattern, the <strong>strategy pattern</strong>. The timer does not know what is supposed to happen when the timer goes off. Therefore we supply an object that does know. The "strategy" for what is to happen is encapsulated in the object. If we supply a different object with a different <code>actionPerformed</code> method, then the result of the timer going off would be different. From the timer's point of view, it simply calls <code>actionPerformed</code> on the object passed to it and it depends on that object to know what the desired behavior is.</p>
<h2 id="events-and-listeners">Events and listeners</h2>
<p>How can we get our applet to do something, such as respond to a mouse click? We will use the same idea that worked for <code>Timer</code>. The answer has two parts:</p>
<ol style="list-style-type: decimal">
<li><p>We have to create an object with a method to handle a specific type of event. The generic name for such an object is a <strong>listener</strong>.</p></li>
<li><p>We have to inform the Java runtime system that this listener object contains a method that should be called every time an event of the type we are interested in occurs. Java will maintain a list of these listener objects for each type of event that it knows about. When an event of some type occurs, it will run through its list of objects for that event and "inform" each of them by calling the method to handle that event that they supplied. (Note that there can be multiple listeners for a certain event, and also that one listener can listen for many different events.)</p></li>
</ol>
<p>We create the object by implementing the interface for the type of event that we are interested in. That way we and Java agree on the names of the methods that will be called when an event occurs.</p>
<p>We tell Java that we want to be informed when a certain event occurs by calling a method to add the listener object to the list of listeners for a particular event. If we indicate an event name by <code>XXX</code>, then the <code>addXXXListener</code> method takes care of this. The object passed must implement the <code>XXXListener</code> interface. Of course, in a real program, we replace <code>XXX</code> by an event name. For example, we are about to see the <code>MouseListener</code> interface and the <code>addMouseListener</code> method, so <code>XXX</code> would be replaced by <code>Mouse</code>.</p>
<h3 id="mouse-events-and-the-mouselistener-interface">Mouse events and the <code>MouseListener</code> interface</h3>
<p>One of the most common events to respond to is a mouse click. Java provides a set of events that are jointly called a <code>MouseEvent</code>:</p>
<ul>
<li><code>mousePressed</code>: the mouse button is pressed down.</li>
<li><code>mouseReleased</code>: the mouse button is released.</li>
<li><code>mouseClicked</code>: the mouse button is pressed down and released without moving the mouse in between.</li>
<li><code>mouseEntered</code>: the mouse cursor moves into the window from outside the window.</li>
<li><code>mouseExited</code>: the mouse cursor moves out of the window from inside the window.</li>
</ul>
<p>When any of these events occurs, an object of type <code>MouseEvent</code> is created and passed to a method designed to handle that event, if one has been "registered" with the component.</p>
<p>The applet <a href="ClickAMac.java">ClickAMac.java</a> illustrates the process. It chooses to have the applet itself implement the <code>MouseListener</code> interface, by stating so at the end of the declaration of the class <code>ClickAMac</code>. The interface requires five methods. One of these, <code>mouseClicked</code>, is actually given code. The other four have empty bodies. When these empty-body events occur, the appropriate method is called, but it returns after doing nothing, ignoring the event.</p>
<p>The program allows the user to click the mouse and then draws a Mac where the mouse was clicked. Let's see how this happens. We have an instance variable <code>clickPoint</code>, which is a reference to a <code>Point</code> object and is initialized to <code>null</code>. A <code>Point</code> is a builtin Java class. It has two instance variables, <code>x</code> and <code>y</code>, which are public rather than private. (I mentioned in a previous lecture that this situation would be one in which you'd want public instance variables.) Therefore if <code>p</code> references a <code>Point</code> object, then <code>p.x</code> is the point's <code>x</code> coordinate and <code>p.y</code> is its <code>y</code> coordininate. The <code>Point</code> class provides a convenient way to package together <code>x</code> and <code>y</code> coordinates.</p>
<p>The <code>init</code> method has the statement <code>addMouseListener(this)</code>. This statement registers the the <code>ClickAMac</code> object as one of the objects that listen for mouse clicks in the applet. When a mouse click occurs, the method <code>this.mouseClicked</code> will be called to deal with it. That's how the code we write to handle events gets called. The rest is similar to <code>SimpleApplet</code>.</p>
<p>The <code>paintComponent</code> method simply calls <code>drawAMac</code> if <code>clickPoint</code> is not <code>null</code>. This <code>drawAMac</code> method contains code that we saw before, but packaged up in a method with all the drawing relative to a <code>Point</code> passed to it, which is the location of the upper left corner of the Mac to be drawn.</p>
<p>At first glance it appears that nothing else will happen. The <code>init</code> method is called when the applet starts, and the <code>paint</code> method is called once, but it does not appear that anything else will happen. And it won't—at least not until the user does something with the mouse in the applet. Then the Java runtime system will run through its list of objects that listen to mouse events. It will call all of the relevent methods (out of <code>mousePressed</code>, <code>mouseReleased</code>, <code>mouseClicked</code>, <code>mouseEntered</code>, and <code>mouseExited</code>) on each such object, passing each one of these methods a reference to a <code>MouseEvent</code> object. Part of the information saved in the <code>MouseEvent</code> object is the point where the mouse was clicked. If you read about the <code>MouseEvent</code> class in the <a href="http://docs.oracle.com/javase/7/docs/api/">Java documentation</a> (look for <code>MouseEvent</code> in the pane whose header reads "All Classes"), you'll see that we can also get the <span class="math"><em>x</em></span>- or <span class="math"><em>y</em></span>-coordinate, the number of clicks that occured (so that we can detect a double or triple click), and other things that we won't worry about now.</p>
<p>For our <code>ClickAMac</code> object, when the mouse is clicked, Java calls the <code>mouseClicked</code> method, passing it a <code>MouseEvent</code> object. This method uses the <code>getPoint</code> method to get the point where the mouse was clicked and saves it in the instance variable <code>clickPoint</code>. It then calls <code>repaint</code>, which causes the Mac to be drawn, with <code>clickPoint</code> supplied as the upper left corner of the Mac. This process is repeated every time the user clicks the mouse in the window.</p>
<h3 id="recap">Recap</h3>
<p>Let's recap how the applet in <a href="ClickAMac.java">ClickAMac.java</a> works:</p>
<ol style="list-style-type: decimal">
<li><p>When the applet runs, the AppletViewer creates a <code>ClickAMac</code> object and runs its <code>init</code> method.</p></li>
<li><p>The <code>init</code> method "registers" that <code>ClickAMac</code> object as a listener for mouse events by calling <code>addMouseListener(this)</code>. (Recall that <code>this</code> is a reference to the object on which the method is invoked. Here, it is a reference to the <code>ClickAMac</code> object.)</p></li>
<li><p>The <code>ClickAMac</code> object has an instance variable <code>clickPoint</code>, which is a reference, initially <code>null</code>, to a <code>Point</code> object. A <code>Point</code> object exists to package together <code>x</code> and <code>y</code> values, both of which are public instance variables.</p></li>
<li><p>Because the <code>ClickAMac</code> class <code>implements MouseListener</code>, it promises to have implementations for the methods <code>mouseClicked</code>, <code>mousePressed</code>, <code>mouseReleased</code>, <code>mouseEntered</code>, and <code>mouseExited</code>. It does provide these implementations. All except <code>mouseClicked</code> have empty bodies, and so they do nothing when called.</p></li>
<li><p>At this point, the applet just waits for something to happen. Even though <code>paintComponent</code> was called when the applet became visible, it didn't draw anything. The instance variable <code>clickPoint</code> was <code>null</code>.</p></li>
<li><p>When one of the mouse events occurs, the part of the Java system that looks for mouse events runs through its own list of objects that have "registered" as caring about mouse events. This <code>ClickAMac</code> object is one such object. The Java system, therefore, calls the appropriate method in this object. For the four mouse events other than a click, the appropriate method does nothing. But if the event was a mouse click, the Java system calls the <code>mouseClicked</code> method.</p></li>
<li><p>When the Java system calls <code>mouseClicked</code>, the parameter passed is a reference to a <code>MouseEvent</code> object named <code>event</code>. By calling <code>event.getPoint()</code>, the <code>mouseClicked</code> method gets a reference to a <code>Point</code> object that gives the location of the mouse at the time of the click.</p></li>
<li><p><code>mouseClicked</code> saves this reference in the instance variable <code>clickPoint</code>. It then calls <code>repaint</code>.</p></li>
<li><p><code>repaint</code> calls <code>paint</code> (and does some other stuff).</p></li>
<li><p><code>paint</code> eventually calls <code>paintComponent</code> in the <code>ClickAMacCanvas</code> object in the content pane of the applet. <code>paintComponent</code> first checks whether <code>clickPoint</code> is <code>null</code>. Of course it isn't <code>null</code>, because we just stored into it. <code>paintComponent</code> then calls <code>DrawAMac</code>, giving it the reference <code>clickPoint</code> to a <code>Point</code>.</p></li>
<li><p><code>DrawAMac</code> draws the Mac, with its top left at the location of the <code>Point</code> it is given.</p></li>
</ol>
<p>Whew! I hope you got all that. Eventually, you'll be more comfortable with it.</p>
<h3 id="the-addmouselistener-method">The <code>addMouseListener</code> method</h3>
<p>If you understand what's going on here, and if you understand interfaces, then it won't surprise you that the <code>addMouseListener</code> method has the following header:</p>
<pre class="sourceCode"><code class="sourceCode java"><span class="kw">public</span> <span class="dt">void</span> <span class="fu">addMouseListener</span>(MouseListener listener)</code></pre>
<p>The formal parameter is declared as a reference to any class that implements the <code>MouseListener</code> interface. That's why in <code>ClickAMac</code>, we can call <code>addMouseListener(this)</code> from the applet's <code>init</code> method: the <code>ClickAMac</code> class does indeed implement the <code>MouseListener</code> interface.</p>
</body>
</html>
